# 1. 웹 브라우저가 메시지를 만든다

## 1. HTTP 리퀘스트 메시지를 작성

URL과 URI의 차이 - URL은 자원이 실제로 존재하는 위치를 가리키며 URI는 자원의 위치뿐만 아니라 자원에 대한 고유 식별자로서 URL의 의미를 포함함



## 2. 웹서버의 IP주소를 DNS서버에 조회

TCP/IP는 **서브넷**이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크가 만들어짐

서브넷 - 허브에 몇 대의 PC가 접속된 것

서브넷(네트워크 번호) + 네트워크 주소(호스트 번호) = IP주소

1. 송신측이 메시지를 보내면 서브넷 안에 있는 허브가 운반
2. 송신측에서 가장 가까운 라우터까지 도착
3. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단
4. 거기에 보내도록 지시하여 송신 동작을 실행
5. 다시 서브넷의 허브가 라우터까지 메시지를 보냄
6. 반복

#### IP주소의 표기방법

1. IP주소 본체의 표기 방법

   10.11.12.13

2. IP주소 본체와 같은 방법으로 네트워크를 표기하는 방법

   10.11.12.13/255.255.255.0 (IP주소본체/넷마스크)

3. 네트워크 번호의 비트 수로 넷마스크를 표기하는 방법

   10.11.12.13/24 (IP주소 본체/넷마스크)

4. 서브넷을 나타내는 주소

   10.11.12.0/24 - 호스트 번호 부분의 비트가 모두 0인 것은 각 컴퓨터가 아니라 서브넷 자체를 나타냄

5. 서브넷의 브로드캐스트를 나타내는 주소

   10.11.12.255/24 - 호스트 번호 부분의 비트가 모두 1인 것은 서브넷 전체에 대한 브로드캐스트를 나타냄

- 실제 IP주소는 32비트의 디지털 데이터로,  8비트씩 점으로 구분하여 10진수로 표기함

- 이것만으로는 어느 부분이 네트워크 번호인지 또는 호스트 번호인지 알 수 없음(IP주소의 규칙에서는 네트워크 번호와 호스트 번호의 두 가지를 합쳐서 32비트로 한다는 것만 결정되어 있기 때문)

- 넷마스크 - 네트워크를 구축할 때 사용자가 직접 내역을 결정할 수 있는데, 이 내역을 나타내는 정보를 필요에 따라 IP주소에 덧붙이는 정보

- IP주소 구조

  ```c++
  1. IP주소  10.   1.  2.3  00001010.00000001.00000010.00000011
  2. 넷마스크 255.255.255.0  11111111.11111111.11111111.00000000
    
  네트워크 번호 - 10. 1. 2.  00001010.00000001.00000010.
  호스트 번호 - 		  3								00000011
  ```

- 넷마스크는 IP주소에서 32비트 부분의 디지털 데이터이며, 왼쪽에 1이 나열되고 오른쪽에 0이 나열된 값이 됨

- 호스트 번호 부분이 모두 0인 IP주소는 각각의 기기를 나타내는 것이 아니라 서브넷 자체를 나타냄

- 호스트 번호 부분이 모두 1이면 서브넷에 있는 기기 전체에 패킷을 보내는 브로드캐스트를 나타냄

#### 도메인명과 IP주소를 구분하여 사용하는 이유

TCP/IP의 네트워크는 IP주소로 통신 상대를 지정하므로 IP 주소를 모르면 상대에게 메시지를 전달할 수 없음. 그러므로 OS에 메시지 송신을 의뢰할 때는 IP주소를 조사해야 함.

#### Socket 라이브러리가 IP 주소를 찾는 기능을 제공함

- DNS 서버에 조회한다는 것은 DNS 서버에 조회 메시지를 보내고, 거기에서 반송되는 응답 메시지를 받는다는 것
- DNS 리졸버 - 조회는 즉, DNS 클라이언트로 동작하는 것. 이에 따라 DNS 클라이언트에 해당하는 것
- name resolution - DNS의 원리를 사용하여 IP주소를 조사하는 것
- 리졸버는 Socket라이브러리에 들어있음

#### resolver를 이용하여 DNS 서버를 조회

```C++
auto IpAddress = gethostbyname("www.~~");
```

#### resolver 내부의 작동

1. 네트워크 애플리케이션이 resolver를 호출하면 제어가 resolver의 내부로 넘어감
2. resolver에서 DNS 서버에 문의하기 위한 메시지를 만듬.
3. DNS 서버에 보냄(OS의 내부에 포함된 프로토콜 스택을 호출하여 실행)
4. resolver가 프로토콜 스택을 호출하면 제어가 resolver에게 넘어가고 여기에서 메시지를 보내는 동작을 실행하여 LAN 어댑터를 통해 메시지가 DNS 서버를 향해 송신됨
5. 액세스 대상의 웹 서버가 DNS 서버에 등록되어 있으면 답이 발견되므로 답을 응답 메시지를 써서 클라이언트에 반송
6. 메시지는 네트워크를 통해 클라이언트측에 도착하고, 프로토콜 스택을 경유하여 resolver에 건네져서 resolver가 내용을 해독한 후 여기에서 IP주소를 추출하여 애플리케이션에 IP 주소를 건네줌



## 3. 전세계의 DNS서버가 연대 

### DNS서버의 기본 동작

DNS서버의 기본 동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일

조회 메시지의 정보

1. 이름

   서버나 메일 배송 목적지(메일 주소에서 @ 뒷부분의 이름)와 같은 이름

2. 클래스

   DNS의 구조를 고안했을 때 인터넷 이외에도 네트워크에서의 이용까지 검토하여 이것을 식별하기 위해 클래스라는 정보를 준비. 그러나 지금은 인터넷 이외의 네트워크는 소멸되었으므로 클래스는 항상 인터넷을 나타내는 'IN'이라는 값이 됨

3. 타입

   이름에 어떤 타입(종류)의 정보가 지원되는지를 나타냄. 예를 들어 타입이 A면 이름에 IP주소가 지원되는 것을 나타내며, MX면 이름에 메일 배송 목적지가 지원된다는 것을 나타냄. 또한 이 타입에 따라 클라이언트에 회답하는 정보의 내용이 달라짐

DNS서버는 등록된 **리소스 레코드**와 비교하여 IP 주소를 회답함

### 도메인의 계층

- 인터넷에는 막대한 수의 서버가 있으므로 이것을 전부 1대의 DNS 서버에 등록하는 것은 불가능
- 따라서 정보를 분산시켜서 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여 어디에 정보가 등록되어 있는지를 찾아내는 구조
- DNS에서 취급하는 이름은 www.lab.cyber.co.kr처럼 점으로 구분되어 있는데, 이 점이 계층을 구분함(오른쪽에 위치한 것이 상위의 계층을 나타냄)
- 도메인 - 계층 하나하나를 도메인이라 하며 kr이라는 도메인 아래에 co도메인, cyber도메인 ... 과 같이 계층형태로 되어있음
- 계층화된 도메인의 정보를 서버에 등록하는데 하나의 도메인을 일괄적으로 취급함.(한 개의 도메인 정보를 일괄적으로 DNS 서버에 등록하고 도메인 한 대의 정보를 분할하여 복수의 DNS 서버에 등록하는 것은 불가능)
- 한 대의 DNS서버에 도메인 한 대를 등록한다고 생각하면 됨

### 담당 DNS 서버를 찾아 IP 주소를 가져옴

1. 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록
2. 상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록하는 식으로 차례대로 등록

Ex) lab.glasscom.com이라는 도메인을 담당하는 DNS 서버를 glasscom.com의 DNS 서버에 등록하고, glasscom.com의 DNS 서버를 com 도메인의 DNS 서버에 등록

- 인터넷의 도메인은 com이나 kr의 상위에 또 하나의 **루트 도메인**이라는 도메인이 있음
- 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 전부 등록하여 어느 DNS 서버도 루트 도메인에 액세스할 수 있게 됨

### DNS 서버는 캐시 기능으로 빠르게 회답할 수 있음

현실의 인터넷에서는 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있으므로 각 도메인에 한대씩 DNS 서버가 존재한다고 단정할 수 없음. 

- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답하기 때문에 그 위치에서 계층 구조를 아래로 향하여 찾을 수 있음
- 조회한 이름이 도메인에 등록되어 있지 않은 경우에는 이름이 존재하지 않는다는 회답이 돌아오지만, 그것을 캐시에 보존할 수도 있음->이름이 존재하지 않는 경우에도 빠르게 회답할 수 있음
- 캐시에 정보를 저장한 후 등록 정보가 변경되는 경우도 있으므로 캐시 안에 저장된 정보는 올바르다고 단언할 수 없음
- 따라서, DNS 서버에 등록하는 정보에는 유효 기한을 설정하고, 캐시에 저장한 데이터의 유효 기간이 지나면 캐시에서 삭제함. 또한 조회에 회답할 때 정보가 캐시에 저장된 것인지, 아니면 등록처 DNS 서버에서 회답한 것인지 알려줌



## 프로토콜 스택에 메시지 송신을 의뢰

### 데이터 송수신 동작의 개요

IP 주소를 조사했으면 IP 주소의 상대에 메시지를 송신하도록 OS의 내부에 있는 프로토콜 스택에 의뢰함.

데이터 송수신 동작

1. 소켓을 만듬(소켓 작성 단계)
2. 서버측의 소켓에 파이프를 연결(접속 단계)
3. 데이터를 송수신(송수신 단계)
4. 파이프를 분리하고 소켓을 말소(연결 끊기 단계)

해당 동작을 실행하는 것은 OS 내부의 프로토콜 스택!