# 2. TCP/IP의 데이터를 전기 신호로 만들어 보냄

## 1. 소켓을 작성

### 프로토콜 스택의 내부 구성

1. 애플리케이션 - 네트워크 애플리케이션(웹 브라우저, 메일러 등)
2. 애플리케이션 - Socket라이브러리(resolver 등)
3. OS - 프로토콜 스택(TCP, UDP)
4. OS - IP(ICMP - 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지, ARP - IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용)
5. 드라이버 소프트웨어 - LAN 드라이버(LAN어댑터의 하드웨어를 제어)
6. 하드웨어 - LAN 어댑터(실제 송수신 동작, 즉 케이블에 대해 신호를 송수신하는 동작을 실행)

### 소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록함(IP주소, 포트번호, 통신 동작의 진행상태 등)
- 프로토콜 스택은 제어 정보를 참조하며 동작함
- 소켓에는 응답이 돌아오는지의 여부와 송신 동작 후의 경과 시간 등이 기록되어 있음
- 프로토콜 스택은 이 정보를 보고 포기하거나 다시 보내는 동작을 실행
- 소켓의 역할 - 프로토콜 스택이 소켓을 참조하여 다음에 무엇을 해야 하는지를 판단

### Socket을 호출했을 때의 동작

1. socket을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만듬
2. 프로토콜 스택이 소켓 한 개 분량의 메모리 영역을 확보함
3. 소켓을 나타내는 디스크립터(커널 오브젝트 핸들)을 애플리케이션에 알려줌
4. 디스크립터(커널 오브젝트 핸들)를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크립터(커널 오브젝트 핸들)를 통지함



## 2. 서버에 접속

### 접속의 의미

- socket을 호출하여 소켓을 만드는 동작만으로는 프로토콜 스택에는 아무것도 전달되지 않음
- 따라서 서버의  IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한가지 역할
- 서버측도 소켓이 만들어졌지만 서버측의 프로토콜 스택도 클라이언트측과 마찬가지로 소켓을 만드는 동작만으로는 통신상태를 알 수 없음
- 또한 서버측은 애플리케이션에서도 상대를 알 수 없으므로 무한히 상대를 알 수 없는 상태
- 따라서 접속을 통해 통신하려는 클라이언트가 있다는 것을 서버측에 전달
- **접속의 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는것**
- 데이터 송수신 동작을 실행할 때는 송수신 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 메모리 영역을 '버퍼 메모리'라고 부름
- 버퍼 메모리의 확보도 접속 동작을 할 때 실행되는데, 이것이 접속한다는 동작의 의미임

### 맨 앞부분에 제어 정보를 기록한 헤더를 배치

제어 정보는 크게 두 가지 종류가 있음

| 필드 명칭                 | 길이(비트) | 설명                                       |
| --------------------- | ------ | ---------------------------------------- |
| 송신처 포트 번호             | 16     | 이 패킷을 송신한 측의 프로그램의 포트 번호                 |
| 수신처 포트 번호             | 16     | 이 패킷을 받는 상대 프로그램의 포트 번호                  |
| 시퀀스 번호(송신 데이터의 일련 번호) | 32     | 이 패킷의 맨 앞 위치의 데이터가 송신 데이터의 몇 번째 바이트에 해당하는지를 송신측에서 수신측에 전달하기 위한 것 |
| ACK 번호(수신 데이터의 일련 번호) | 32     | 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에 전달하기 위한 것. |
| 데이터 오프셋               | 4      | 데이터 부분이 어디부터 시작하는지를 나타냄. 헤더의 길이를 나타냄     |
| 사용하지 않음               | 6      | 이 필드는 사용하지 않음                            |
| 컨트롤 비트                | 6      | 이 필드의 각 비트가 각각 통신 제어상의 의미를 가짐<br />- URG: 긴급 포인터의 필드가 유효<br />- ACK: 수신 데이터의 일련번호 필드가 유효. 보통 데이터가 올바르게 수신측에 도착한 것을 의미<br />- PSH: flush 동작에 의해 송신된 데이터<br />- RST: 접속을 |
| 윈도우                   | 16     | 수신측에서 송신측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터 양)를 통지하기 위해 사용 |
| 체크섬                   | 16     | 오류 유무를 검사하기 위한 것                         |

- 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음 -> 규칙에 따라 헤더에 제어 정보를 기록하여 대화하면, 그것으로 클라이언트와 서버가 서로 연락을 취하기 때문
- 윈도우와 리눅스는 프로토콜 스택을 만드는 방법이 다르므로 필요한 제어 정보도 다를것. 그러나 문제없이 통신할 수 있으며, 컴퓨터와 휴대전화로 통신할 때도 마찬가지임

### 접속 동작의 실제

1. connect를 호출
2. 명령이 프로토콜 스택의 TCP 담당 부분에 전달
3. TCP 담당 부분은 IP 주소로 표시된 상대, 즉 서버의 TCP 담당 부분과의 사이에 제어 정보를 주고받음
4. 데이터 송수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만듬
5. 헤더에는 다수의 항목이 있는데, 송신처와 수신처의 포트번호를 통해 양측의 소켓을 지정할 수 있음
6. 즉, 접속해야하는 소켓이 어느 것인지 확실히 하고 컨트롤 비트인 SYN이라는 비트를 1로 만듬
7. 이렇게 TCP 헤더를 만들면 이것을 IP 담당 부분에 건네주어 송신하도록 의뢰
8. IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네줌
9. 서버측의 TCP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아냄
10. 접속을 기다리는 상태에 있는 소켓 중에서 TCP 헤더의 수신처 포트 번호와 같은 번호가 기록된 것이 해당하는 소켓임
11. 해당하는 소켓이 발견되면 여기에 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태가 됨
12. 이 과정이 끝나면 서버의 TCP 담당 부분은 응답을 돌려보냄
13. 클라이언트와 마찬가지로 송신처와 수신처의 포트 번호나 SYN 비트 등을 설정한 TCP 헤더를 만들고 응답을 돌려보낼 때 ACK 라는 컨트롤 비트도 1로 만듬
14. 패킷을 받은 것을 알리기 위한 동작
15. 네트워크에는 오류가 있을 수 있으므로 패킷이 없어지는 경우에는 패킷이 도착한 것을 확인하는 동작이 진행됨
16. 패킷이 클라이언트에 돌아오고 IP 담당 부분을 경유하여 TCP 담당 부분에 도착
17. TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 확인
18. SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록
19. ACK 비트를 1로 만든 TCP 헤더를 반송



## 3. 데이터 송수신

### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘김

- 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다림
- 데이터를 저장하는 이유 - 송신을 의뢰할 때 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션의 종류나 만드는 방법에 따라 결정됨.(데이터를 전부 한꺼번에 보내던지, 1바이트씩 또는 1행씩 세분하여 보내던지..) -> 어느 경우든지 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 애플리케이션의 사정에 따라 결정되며, 프로토콜 스택에서 제어할 수 없음. 이러한 상황에서 받은 데이터를 곧바로 보내면 작은 패킷을 많이 보낼 수 있고, 이는 네트워크의 이용 효율 저하로 이어지므로 어느 정도 데이터를 저장하고 나서 송수신 동작을 함
- 송수신을 판단하는 요소 - 한 패킷에 저장할 수 있는 데이터의 크기
  - MTU - 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1500바이트. 
  - MSS - 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
- 송수신을 판단하는 요소 - 타이밍
  - 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신
- 전자를 중시하면 패킷 길이가 길어져 네트워크의 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 있음. 반대의 경우도 있음...
- TCP 프로토콜의 사양에는 절충에 관한 규정은 없으며, 실제로 어떻게 판단해야 할지는 프로토콜 스택을 만드는 개발자에 달려있음

### 데이터가 클 때는 분할하여 보냄

- 긴 데이터를 보낼 경우 등 한 개의 패킷에 들어가지 않을 만큼 긴 데이터는 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 없음. 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신
- 송신 버퍼에 저장한 데이터 조각의 모습을 가늠하여 데이터 조각을 송신하면 맨 앞부분에 TCP 헤더를 부가함.
- 소켓에 기록되어 있는 제어 정보를 바탕으로 송신처 포트 번호나 수신처 포트 번호 등 필요한 항목을 기록하고 IP담당 부분에 건네주어 송신 동작을 실행

### ACK 번호를 사용하여 패킷이 도착했는지 확인

- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어감

1. TCP 담당 부분은 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지를 세어둠
2. 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데, 이가 **시퀀스 번호**
3. 송신하는 데이터의 크기를 헤더에 기록
4. 패킷 전체 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있으므로 수신측에서 이 방법에 따라 크기를 산출
5. 송신한 데이터가 몇 번째 바이트부터 시작되는 몇 바이트 분의 것인지 알 수 있음

- ACK 번호: 시퀀스 번호 + 크기가 되며 이 ACK 번호를 되돌려주는 동작을 통해 수신 확인 응답을 함. 이를 통해 상대가 어디까지 수신했는지를 파악함
- TCP의 데이터 송수신 동작은 양방향이므로 두 가지 데이터 흐름이 모두 위와 같이 동작해야 함. -> 좌우를 역전시킨 것을 덧붙이면 됨

#### 실제 움직임

1. 클라이언트가 서버에 시퀀스 번호 초기값을 보냄
2. 서버가 클라이언트에 ACK번호와 시퀀스 번호 초기값을 보냄
3. 클라이언트가 서버에 ACK 번호를 보냄

-------------connect 동작--------------

4. 클라이언트(서버)가 서버(클라이언트)에 시퀀스 번호 + 데이터를 보냄
5. 서버(클라이언트)가 클라(서버)에 ACK번호를 보냄

--------------송수신동작---------------

- 위 구조는 수신측에 패킷이 올바르게 도착한 것을 확인하고 도착하지 않으면 다시 보내므로 네트워크의 어디에서 오류가 발생했더라도 그것을 전부 검출하여 회복 처리를 취할 수 있음
- 따라서, LAN 어댑터, 버퍼, 라우터 모두 회복 조취를 취하지 않음
- 도중에 케이블이 분리되거나 서버가 다운되는 등의 이유로 TCP가 아무리 다시 보내도 데이터가 도착하지 않으면 데이터 송신동작을 강제로 종료하고 애플리케이션에 오류를 통지함

### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정

타임아웃 값 - ACK 번호가 돌아오는 것을 기다리는 시간

- 네트워크가 혼잡하여 정체가 일어나면 ACK 번호가 돌아오는 것이 지연되므로 이것을 예측하여 대기 시간을 어느 정도 길게 설정해야 함
- 반면에 너무 길면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 됨
- 따라서 TCP는 대기 시간을 동적으로 변경하는 방법을 취하고 있음.
- ACK번호가 돌아오는 시간을 기준으로 대기 시간을 판단.(데이터 송신 동작을 실행하고 있을 때 항상 ACK번호가 돌아오는 시간을 계측해둠)

### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리

- ACK 번호가 돌아올 때까지의 시간 동안 아무 일도 하지 않고 기다리는 것은 시간낭비
- TCP는 윈도우 제어라는 방식에 따라 송신과 ACK 번호 통지의 동작을 실행함
- 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법

#### 윈도우 제어 방식

1. 수신측의 TCP는 패킷을 수신하면 일단 수신용 버퍼 메모리에 데이터를 일시 보관
2. 수신측에서는 ACK 번호를 계산하거나 조각을 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네주어야 함
3. 애플리케이션에 건네주는 속도보다 빠른 속도로 데이터가 도착하면 수신버퍼에 데이터가 쌓여서 넘쳐버림.
4. 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실행

- 수신측은 수신 버퍼에 데이터를 임시 보관하고 수신 처리를 진행
- 수신 처리가 끝나고 수신 버퍼에 빈 부부닝 생기면 그 분량만큼 수신할 수 있는 데이터의 양을 늘리므로 TCP 헤더의 윈도우 필드에서 이것을 송신측에 알림
- 윈도우 사이즈 - 수신 가능한 데이터 양의 최대값. TCP를 정밀 조정하는 매개변수의 하나

### ACK 번호와 윈도우를 합승

- 윈도우 통지가 필요한 것은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때
- ACK 번호는 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보냄
- 수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다림.
- 기다리는 사이에 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 보냄.
- 복수의 ACK 번호 통지가 연속해서 일어난 경우에도 패킷의 수를 줄일 수 있음. ACK 번호는 데이터를 어디까지 받았는지, 즉 수신한 데이터의 끝이 어디인지를 알리는 것이므로 ACK 번호 통지가 연속하여 일어나면 최후의 것만 통지하고 도중의 것은 생략해도 상관없음 -> 패킷 줄일 수 있음
- 윈도우 통지도 위와 마찬가지.

### HTTP 응답 메시지를 수신

1. 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네줌
2. 리퀘스트 메시지의 송신을 완료
3. 응답 메시지가 돌아올 때까지 다소 시간이 걸리므로 수신 버퍼에 데이터가 들어가지 않음
4. 프로토콜 스택은 의뢰받은 작업, 즉 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네주는 작업을 보류
5. 서버에서 응답 메시지의 패킷이 도착했을 때 그것을 수신하여 애플리케이션에 건네주는 작업을 재개



## 서버에서 연결을 끊어 소켓을 말소

### 데이터 보내기를 완료했을 때 연결을 끊음

- 데이터 송수신을 종료하는 것은 애플리케이션이 송신해야 하는 데이터를 전부 송신 완료했다고 판단했을 때
- 송신을 완료한 측이 연결 끊기 단계로 들어가는데, 어디에서 데이터 송수신 동작이 끝나는지는 애플리케이션에 따라 다름

#### 서버측에서 연결 끊기 단계에 들어가는 경우

1. 서버측의 애플리케이션이 close를 호출함
2. 서버측의 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결 끊기를 나타내는 정보를 설정함(컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해달라고 함)
3. 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록
4. 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록
5. FIN을 1로 설정한 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송하고, 이것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다림
6. 애플리케이션이 read를 호출하여 데이터를 가지러 오면 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 애플리케이션에 알림
7. 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송수신 동작을 끝냄
8. 클라이언트측의 프로토콜 스택은 서버측과 마찬가지로 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 송신한 후 서버에서 ACK 번호가 돌아오면 서버와의 통신이 끝남

### 소켓을 말소

서버와의 통신이 끝나면 소켓을 사용하여 서버와 통신할 수 없게 됨. 이 때 소켓은 필요 없지만, 거기서 바로 소켓을 말소하지 않고 잠시 기다린 후 소켓을 말소함

1. 클라이언트가 FIN 송신
2. 서버가 ACK 번호 송신
3. 서버가 FIN 송신
4. 클라이언트가 ACK 번호 송신

이 경우 소켓이 바로 말소되었으면 ACK 번호를 송신할 수 없음.

명확한 규정은 없으나 일반적으로 보통 몇 분 정도 기다리고 나서 소켓을 말소함

### 데이터 송수신 동작을 정리

1. 서버측에서 애플리케이션을 동작시켜 소켓을 만들고 접속 대기 상태로 만듬
2. 클라이언트에서 애플리케이션을 동작시켜 소켓을 만들고 서버를 향해 접속 동작을 실행
3. 클라이언트가 SYN을 1로 만든 TCP 헤더를 서버에 보냄(시퀀스 번호의 초기값 포함, 서버가 송신할 때 이용하는 윈도우 통지값도 기록되어있음)
4. 서버에서 SYN을 1로 만든 TCP의 헤더가 돌아옴(클라와 마찬가지의 헤더)
5. 접속이 끝나고 데이터 송수신 단계에 들어감
6. 클라이언트(서버)에서 전송할 데이터를 작성하여 TCP계층에 넘겨줌
7. TCP계층에서 적당한 크기의 조각으로 분할하고 TCP 헤더를 맨 앞에 부가하여 서버(클라이언트)에 전송.(시퀀스 번호 포함)
8. 서버(클라이언트)가 ACK 번호를 클라이언트(서버)에 반송
9. 최초의 데이터 조각인 경우 서버(클라이언트)는 받기만 하지만 데이터 송수신이 진행되면 애플리케이션에 데이터를 건네주어 수신 버퍼에 빈 영역이 생기는데, 이 때 윈도우의 값도 기록하여 클라이언트(서버)에 통지
10. 클라이언트(서버)에서 서버(클라이언트)에 리퀘스트 메시지를 보내면 서버(클라이언트)가 응답 메시지를 반송
11. 연결 끊기 단계에 들어감
12. 서버(클라이언트)가 FIN을 1로 만든 TCP 헤더를 전송함
13. 이것을 받은 클라이언트(서버)가 ACK 번호의 TCP 헤더를 반송
14. 이후 클라이언트(서버)가 FIN을 1로 만든 TCP의 헤더를 전송
15. 마지막으로 서버(클라이언트)가 ACK를 보내며 끝



## IP와 이더넷의 패킷 송수신 동작

### 패킷의 기본

- 패킷은 **헤더**와 **데이터**의 두 부분으로 구성됨
- 헤더에는 수신처를 나타내는 주소 등의 제어 정보가 들어있음
- 패킷의 송신처가 되는 기기가 패킷을 만들고 가장 가까운 중계 장치에 송신
- 패킷이 가장 가까운 중계 장치에 도착하고, 중계 장치는 도착한 패킷의 헤더를 조사하여 패킷의 목적지를 판단(수신처가 어느 방향에 있는지에 대한 정보를 기록한 표와 같은 것을 사용)
- 송신처였던 기기가 수신처가 되는 상태의 경우 명확하게 구별하지 않는 편이 편리할 수 있음. 이러한 경우 송신처와 수신처의 기기를 묶어 '엔드 노드'라고 함
- 패킷 운반에 있어 라우터와 허브의 역할
  1. 라우터가 목적지를 확인하여 다음 라우터를 나타냄 - IP의 규칙 사용(MAC 헤더)
  2. 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착 - 이더넷의 규칙 사용(IP 헤더)

1. 송신처에서 패키스이 목적지가 되는 액세스 대상 서버의 IP 주소를 IP 헤더의 수신처에 기록함
2. 패킷의 목적지가 분명해지므로 IP는 이 수신처가 어느 방향에 있는지를 조사하고, 그 방향에 있는 다음 라우터를 조사함
3. 조사한 라우터에 도착하도록 이더넷의 의뢰함
4. 다음 라우터에 할당된 이더넷의 주소(MAC주소)를 조사하고, 그것은 MAC 헤더에 기록
5. 반복

- 허브는 패킷의 목적지를 판단하기 위한 이더넷용 표가 있어 이더넷의 헤더의 수신처 정보와 표를 결합해 패킷의 목적지를 판단하여 중계함
- 허브가 복수면 허브를 순차적으로 경유하여 패킷이 진행됨
- 패킷이 다음 라우터에 도착하면 다음에 어느 라우터에 패킷을 중계하면 좋을지를 결정
- 다음 라우터에 패킷을 건네기 위해 라우터의 MAC 주소를 조사하고, MAC 헤더를 바꿔쓰어 패킷을 다음 라우터에 전송
- 무선 LAN, ADSL, FTTH 등 IP의 의뢰를 받아 패킷을 운반할 수 있는 것이면 무엇이든지 이더넷 대신 사용할 수 있음

### 패킷 송수신 동작의 개요

