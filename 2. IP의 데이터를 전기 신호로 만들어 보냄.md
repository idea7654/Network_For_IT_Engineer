# 2. TCP/IP의 데이터를 전기 신호로 만들어 보냄

## 1. 소켓을 작성

### 프로토콜 스택의 내부 구성

1. 애플리케이션 - 네트워크 애플리케이션(웹 브라우저, 메일러 등)
2. 애플리케이션 - Socket라이브러리(resolver 등)
3. OS - 프로토콜 스택(TCP, UDP)
4. OS - IP(ICMP - 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지, ARP - IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용)
5. 드라이버 소프트웨어 - LAN 드라이버(LAN어댑터의 하드웨어를 제어)
6. 하드웨어 - LAN 어댑터(실제 송수신 동작, 즉 케이블에 대해 신호를 송수신하는 동작을 실행)

### 소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록함(IP주소, 포트번호, 통신 동작의 진행상태 등)
- 프로토콜 스택은 제어 정보를 참조하며 동작함
- 소켓에는 응답이 돌아오는지의 여부와 송신 동작 후의 경과 시간 등이 기록되어 있음
- 프로토콜 스택은 이 정보를 보고 포기하거나 다시 보내는 동작을 실행
- 소켓의 역할 - 프로토콜 스택이 소켓을 참조하여 다음에 무엇을 해야 하는지를 판단

### Socket을 호출했을 때의 동작

1. socket을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만듬
2. 프로토콜 스택이 소켓 한 개 분량의 메모리 영역을 확보함
3. 소켓을 나타내는 디스크립터(커널 오브젝트 핸들)을 애플리케이션에 알려줌
4. 디스크립터(커널 오브젝트 핸들)를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크립터(커널 오브젝트 핸들)를 통지함



## 2. 서버에 접속

### 접속의 의미

- socket을 호출하여 소켓을 만드는 동작만으로는 프로토콜 스택에는 아무것도 전달되지 않음
- 따라서 서버의  IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한가지 역할
- 서버측도 소켓이 만들어졌지만 서버측의 프로토콜 스택도 클라이언트측과 마찬가지로 소켓을 만드는 동작만으로는 통신상태를 알 수 없음
- 또한 서버측은 애플리케이션에서도 상대를 알 수 없으므로 무한히 상대를 알 수 없는 상태
- 따라서 접속을 통해 통신하려는 클라이언트가 있다는 것을 서버측에 전달
- **접속의 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는것**
- 데이터 송수신 동작을 실행할 때는 송수신 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 메모리 영역을 '버퍼 메모리'라고 부름
- 버퍼 메모리의 확보도 접속 동작을 할 때 실행되는데, 이것이 접속한다는 동작의 의미임

### 맨 앞부분에 제어 정보를 기록한 헤더를 배치

제어 정보는 크게 두 가지 종류가 있음

| 필드 명칭                 | 길이(비트) | 설명                                       |
| --------------------- | ------ | ---------------------------------------- |
| 송신처 포트 번호             | 16     | 이 패킷을 송신한 측의 프로그램의 포트 번호                 |
| 수신처 포트 번호             | 16     | 이 패킷을 받는 상대 프로그램의 포트 번호                  |
| 시퀀스 번호(송신 데이터의 일련 번호) | 32     | 이 패킷의 맨 앞 위치의 데이터가 송신 데이터의 몇 번째 바이트에 해당하는지를 송신측에서 수신측에 전달하기 위한 것 |
| ACK 번호(수신 데이터의 일련 번호) | 32     | 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에 전달하기 위한 것. |
| 데이터 오프셋               | 4      | 데이터 부분이 어디부터 시작하는지를 나타냄. 헤더의 길이를 나타냄     |
| 사용하지 않음               | 6      | 이 필드는 사용하지 않음                            |
| 컨트롤 비트                | 6      | 이 필드의 각 비트가 각각 통신 제어상의 의미를 가짐<br />- URG: 긴급 포인터의 필드가 유효<br />- ACK: 수신 데이터의 일련번호 필드가 유효. 보통 데이터가 올바르게 수신측에 도착한 것을 의미<br />- PSH: flush 동작에 의해 송신된 데이터<br />- RST: 접속을 |
| 윈도우                   | 16     | 수신측에서 송신측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터 양)를 통지하기 위해 사용 |
| 체크섬                   | 16     | 오류 유무를 검사하기 위한 것                         |

- 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음 -> 규칙에 따라 헤더에 제어 정보를 기록하여 대화하면, 그것으로 클라이언트와 서버가 서로 연락을 취하기 때문
- 윈도우와 리눅스는 프로토콜 스택을 만드는 방법이 다르므로 필요한 제어 정보도 다를것. 그러나 문제없이 통신할 수 있으며, 컴퓨터와 휴대전화로 통신할 때도 마찬가지임

### 접속 동작의 실제

1. connect를 호출
2. 명령이 프로토콜 스택의 TCP 담당 부분에 전달
3. TCP 담당 부분은 IP 주소로 표시된 상대, 즉 서버의 TCP 담당 부분과의 사이에 제어 정보를 주고받음
4. 데이터 송수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만듬
5. 헤더에는 다수의 항목이 있는데, 송신처와 수신처의 포트번호를 통해 양측의 소켓을 지정할 수 있음
6. 즉, 접속해야하는 소켓이 어느 것인지 확실히 하고 컨트롤 비트인 SYN이라는 비트를 1로 만듬
7. 이렇게 TCP 헤더를 만들면 이것을 IP 담당 부분에 건네주어 송신하도록 의뢰
8. IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네줌
9. 서버측의 TCP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아냄
10. 접속을 기다리는 상태에 있는 소켓 중에서 TCP 헤더의 수신처 포트 번호와 같은 번호가 기록된 것이 해당하는 소켓임
11. 해당하는 소켓이 발견되면 여기에 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태가 됨
12. 이 과정이 끝나면 서버의 TCP 담당 부분은 응답을 돌려보냄
13. 클라이언트와 마찬가지로 송신처와 수신처의 포트 번호나 SYN 비트 등을 설정한 TCP 헤더를 만들고 응답을 돌려보낼 때 ACK 라는 컨트롤 비트도 1로 만듬
14. 패킷을 받은 것을 알리기 위한 동작
15. 네트워크에는 오류가 있을 수 있으므로 패킷이 없어지는 경우에는 패킷이 도착한 것을 확인하는 동작이 진행됨
16. 패킷이 클라이언트에 돌아오고 IP 담당 부분을 경유하여 TCP 담당 부분에 도착
17. TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 확인
18. SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록
19. ACK 비트를 1로 만든 TCP 헤더를 반송



## 3. 데이터 송수신

### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘김

- 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다림
- 데이터를 저장하는 이유 - 송신을 의뢰할 때 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션의 종류나 만드는 방법에 따라 결정됨.(데이터를 전부 한꺼번에 보내던지, 1바이트씩 또는 1행씩 세분하여 보내던지..) -> 어느 경우든지 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 애플리케이션의 사정에 따라 결정되며, 프로토콜 스택에서 제어할 수 없음. 이러한 상황에서 받은 데이터를 곧바로 보내면 작은 패킷을 많이 보낼 수 있고, 이는 네트워크의 이용 효율 저하로 이어지므로 어느 정도 데이터를 저장하고 나서 송수신 동작을 함
- 송수신을 판단하는 요소 - 한 패킷에 저장할 수 있는 데이터의 크기
  - MTU - 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1500바이트. 
  - MSS - 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
- 송수신을 판단하는 요소 - 타이밍
  - 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신
- 전자를 중시하면 패킷 길이가 길어져 네트워크의 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 있음. 반대의 경우도 있음...
- TCP 프로토콜의 사양에는 절충에 관한 규정은 없으며, 실제로 어떻게 판단해야 할지는 프로토콜 스택을 만드는 개발자에 달려있음

### 데이터가 클 때는 분할하여 보냄

- 긴 데이터를 보낼 경우 등 한 개의 패킷에 들어가지 않을 만큼 긴 데이터는 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 없음. 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신
- 송신 버퍼에 저장한 데이터 조각의 모습을 가늠하여 데이터 조각을 송신하면 맨 앞부분에 TCP 헤더를 부가함.
- 소켓에 기록되어 있는 제어 정보를 바탕으로 송신처 포트 번호나 수신처 포트 번호 등 필요한 항목을 기록하고 IP담당 부분에 건네주어 송신 동작을 실행

### ACK 번호를 사용하여 패킷이 도착했는지 확인

- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어감

1. TCP 담당 부분은 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지를 세어둠
2. 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데, 이가 **시퀀스 번호**
3. 송신하는 데이터의 크기를 헤더에 기록
4. 패킷 전체 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있으므로 수신측에서 이 방법에 따라 크기를 산출
5. 송신한 데이터가 몇 번째 바이트부터 시작되는 몇 바이트 분의 것인지 알 수 있음

- ACK 번호: 시퀀스 번호 + 크기가 되며 이 ACK 번호를 되돌려주는 동작을 통해 수신 확인 응답을 함. 이를 통해 상대가 어디까지 수신했는지를 파악함
- ​