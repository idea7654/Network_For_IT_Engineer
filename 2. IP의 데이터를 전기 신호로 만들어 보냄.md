# 2. TCP/IP의 데이터를 전기 신호로 만들어 보냄

## 1. 소켓을 작성

### 프로토콜 스택의 내부 구성

1. 애플리케이션 - 네트워크 애플리케이션(웹 브라우저, 메일러 등)
2. 애플리케이션 - Socket라이브러리(resolver 등)
3. OS - 프로토콜 스택(TCP, UDP)
4. OS - IP(ICMP - 패킷을 운반할 때 발생하는 오류를 통지하거나 제어용 메시지를 통지, ARP - IP 주소에 대응하는 이더넷의 MAC 주소를 조사할 때 사용)
5. 드라이버 소프트웨어 - LAN 드라이버(LAN어댑터의 하드웨어를 제어)
6. 하드웨어 - LAN 어댑터(실제 송수신 동작, 즉 케이블에 대해 신호를 송수신하는 동작을 실행)

### 소켓의 실체는 통신 제어용 제어 정보

- 프로토콜 스택은 내부에 제어 정보를 기록하는 메모리 영역을 가지고 있으며, 여기에 통신 동작을 제어하기 위한 제어 정보를 기록함(IP주소, 포트번호, 통신 동작의 진행상태 등)
- 프로토콜 스택은 제어 정보를 참조하며 동작함
- 소켓에는 응답이 돌아오는지의 여부와 송신 동작 후의 경과 시간 등이 기록되어 있음
- 프로토콜 스택은 이 정보를 보고 포기하거나 다시 보내는 동작을 실행
- 소켓의 역할 - 프로토콜 스택이 소켓을 참조하여 다음에 무엇을 해야 하는지를 판단

### Socket을 호출했을 때의 동작

1. socket을 호출하여 소켓을 만들 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만듬
2. 프로토콜 스택이 소켓 한 개 분량의 메모리 영역을 확보함
3. 소켓을 나타내는 디스크립터(커널 오브젝트 핸들)을 애플리케이션에 알려줌
4. 디스크립터(커널 오브젝트 핸들)를 받은 애플리케이션은 이후 프로토콜 스택에 데이터 송수신 동작을 의뢰할 때 디스크립터(커널 오브젝트 핸들)를 통지함



## 2. 서버에 접속

### 접속의 의미

- socket을 호출하여 소켓을 만드는 동작만으로는 프로토콜 스택에는 아무것도 전달되지 않음
- 따라서 서버의  IP 주소나 포트 번호를 프로토콜 스택에 알리는 동작이 필요한데, 이것이 접속 동작의 한가지 역할
- 서버측도 소켓이 만들어졌지만 서버측의 프로토콜 스택도 클라이언트측과 마찬가지로 소켓을 만드는 동작만으로는 통신상태를 알 수 없음
- 또한 서버측은 애플리케이션에서도 상대를 알 수 없으므로 무한히 상대를 알 수 없는 상태
- 따라서 접속을 통해 통신하려는 클라이언트가 있다는 것을 서버측에 전달
- **접속의 첫 번째 동작은 통신 상대와의 사이에 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는것**
- 데이터 송수신 동작을 실행할 때는 송수신 데이터를 일시적으로 저장하는 메모리 영역이 필요한데, 이 메모리 영역을 '버퍼 메모리'라고 부름
- 버퍼 메모리의 확보도 접속 동작을 할 때 실행되는데, 이것이 접속한다는 동작의 의미임

### 맨 앞부분에 제어 정보를 기록한 헤더를 배치

제어 정보는 크게 두 가지 종류가 있음

| 필드 명칭                 | 길이(비트) | 설명                                       |
| --------------------- | ------ | ---------------------------------------- |
| 송신처 포트 번호             | 16     | 이 패킷을 송신한 측의 프로그램의 포트 번호                 |
| 수신처 포트 번호             | 16     | 이 패킷을 받는 상대 프로그램의 포트 번호                  |
| 시퀀스 번호(송신 데이터의 일련 번호) | 32     | 이 패킷의 맨 앞 위치의 데이터가 송신 데이터의 몇 번째 바이트에 해당하는지를 송신측에서 수신측에 전달하기 위한 것 |
| ACK 번호(수신 데이터의 일련 번호) | 32     | 데이터가 몇 바이트까지 수신측에 도착했는지를 수신측에서 송신측에 전달하기 위한 것. |
| 데이터 오프셋               | 4      | 데이터 부분이 어디부터 시작하는지를 나타냄. 헤더의 길이를 나타냄     |
| 사용하지 않음               | 6      | 이 필드는 사용하지 않음                            |
| 컨트롤 비트                | 6      | 이 필드의 각 비트가 각각 통신 제어상의 의미를 가짐<br />- URG: 긴급 포인터의 필드가 유효<br />- ACK: 수신 데이터의 일련번호 필드가 유효. 보통 데이터가 올바르게 수신측에 도착한 것을 의미<br />- PSH: flush 동작에 의해 송신된 데이터<br />- RST: 접속을 |
| 윈도우                   | 16     | 수신측에서 송신측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터 양)를 통지하기 위해 사용 |
| 체크섬                   | 16     | 오류 유무를 검사하기 위한 것                         |

- 소켓에 기록한 제어 정보는 상대측에서 볼 수 없음 -> 규칙에 따라 헤더에 제어 정보를 기록하여 대화하면, 그것으로 클라이언트와 서버가 서로 연락을 취하기 때문
- 윈도우와 리눅스는 프로토콜 스택을 만드는 방법이 다르므로 필요한 제어 정보도 다를것. 그러나 문제없이 통신할 수 있으며, 컴퓨터와 휴대전화로 통신할 때도 마찬가지임

### 접속 동작의 실제

1. connect를 호출
2. 명령이 프로토콜 스택의 TCP 담당 부분에 전달
3. TCP 담당 부분은 IP 주소로 표시된 상대, 즉 서버의 TCP 담당 부분과의 사이에 제어 정보를 주고받음
4. 데이터 송수신 동작의 개시를 나타내는 제어 정보를 기록한 헤더를 만듬
5. 헤더에는 다수의 항목이 있는데, 송신처와 수신처의 포트번호를 통해 양측의 소켓을 지정할 수 있음
6. 즉, 접속해야하는 소켓이 어느 것인지 확실히 하고 컨트롤 비트인 SYN이라는 비트를 1로 만듬
7. 이렇게 TCP 헤더를 만들면 이것을 IP 담당 부분에 건네주어 송신하도록 의뢰
8. IP 담당 부분이 패킷 송신 동작을 실행하고 네트워크를 통해 패킷이 서버에 도착하면 서버측의 IP 담당 부분이 이것을 받아 TCP 담당 부분에 건네줌
9. 서버측의 TCP 담당 부분이 TCP 헤더를 조사하여 기록되어 있는 수신처 포트 번호에 해당하는 소켓을 찾아냄
10. 접속을 기다리는 상태에 있는 소켓 중에서 TCP 헤더의 수신처 포트 번호와 같은 번호가 기록된 것이 해당하는 소켓임
11. 해당하는 소켓이 발견되면 여기에 필요한 정보를 기록하고 접속 동작이 진행중이라는 상태가 됨
12. 이 과정이 끝나면 서버의 TCP 담당 부분은 응답을 돌려보냄
13. 클라이언트와 마찬가지로 송신처와 수신처의 포트 번호나 SYN 비트 등을 설정한 TCP 헤더를 만들고 응답을 돌려보낼 때 ACK 라는 컨트롤 비트도 1로 만듬
14. 패킷을 받은 것을 알리기 위한 동작
15. 네트워크에는 오류가 있을 수 있으므로 패킷이 없어지는 경우에는 패킷이 도착한 것을 확인하는 동작이 진행됨
16. 패킷이 클라이언트에 돌아오고 IP 담당 부분을 경유하여 TCP 담당 부분에 도착
17. TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 확인
18. SYN이 1이면 접속 성공이므로 소켓에 서버의 IP 주소나 포트 번호 등과 함께 소켓에 접속 완료를 나타내는 제어 정보를 기록
19. ACK 비트를 1로 만든 TCP 헤더를 반송



## 3. 데이터 송수신

### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘김

- 프로토콜 스택은 받은 데이터를 곧바로 송신하는 것이 아니라 일단 자체의 내부에 있는 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션이 다음 데이터를 건네주기를 기다림
- 데이터를 저장하는 이유 - 송신을 의뢰할 때 애플리케이션에서 프로토콜 스택에 건네주는 데이터의 길이는 애플리케이션의 종류나 만드는 방법에 따라 결정됨.(데이터를 전부 한꺼번에 보내던지, 1바이트씩 또는 1행씩 세분하여 보내던지..) -> 어느 경우든지 한 번의 송신 의뢰에서 건네주는 데이터의 길이는 애플리케이션의 사정에 따라 결정되며, 프로토콜 스택에서 제어할 수 없음. 이러한 상황에서 받은 데이터를 곧바로 보내면 작은 패킷을 많이 보낼 수 있고, 이는 네트워크의 이용 효율 저하로 이어지므로 어느 정도 데이터를 저장하고 나서 송수신 동작을 함
- 송수신을 판단하는 요소 - 한 패킷에 저장할 수 있는 데이터의 크기
  - MTU - 한 패킷으로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1500바이트. 
  - MSS - 헤더를 제외하고 한 개의 패킷으로 운반할 수 있는 TCP의 데이터의 최대 길이
- 송수신을 판단하는 요소 - 타이밍
  - 프로토콜 스택은 내부에 타이머가 있어서 이것으로 일정 시간 이상 경과하면 패킷을 송신
- 전자를 중시하면 패킷 길이가 길어져 네트워크의 효율이 높아지지만 버퍼에 머무는 시간만큼 송신 동작이 지연될 우려가 있음. 반대의 경우도 있음...
- TCP 프로토콜의 사양에는 절충에 관한 규정은 없으며, 실제로 어떻게 판단해야 할지는 프로토콜 스택을 만드는 개발자에 달려있음

### 데이터가 클 때는 분할하여 보냄

- 긴 데이터를 보낼 경우 등 한 개의 패킷에 들어가지 않을 만큼 긴 데이터는 MSS의 길이를 초과하므로 다음 데이터를 기다릴 필요가 없음. 따라서 송신 버퍼에 들어있는 데이터를 맨 앞부터 차례대로 MSS의 크기에 맞게 분할하고, 분할한 조각을 한 개씩 패킷에 넣어 송신
- 송신 버퍼에 저장한 데이터 조각의 모습을 가늠하여 데이터 조각을 송신하면 맨 앞부분에 TCP 헤더를 부가함.
- 소켓에 기록되어 있는 제어 정보를 바탕으로 송신처 포트 번호나 수신처 포트 번호 등 필요한 항목을 기록하고 IP담당 부분에 건네주어 송신 동작을 실행

### ACK 번호를 사용하여 패킷이 도착했는지 확인

- TCP에는 송신한 패킷이 상대에게 올바르게 도착했는지 확인하고, 도착하지 않았으면 다시 송신하는 기능이 있으므로 패킷을 송신한 후에는 확인 동작으로 넘어감

1. TCP 담당 부분은 데이터를 조각으로 분할할 때 조각이 통신 개시부터 따져서 몇 번째 바이트에 해당하는지를 세어둠
2. 데이터의 조각을 송신할 때 세어둔 값을 TCP 헤더에 기록하는데, 이가 **시퀀스 번호**
3. 송신하는 데이터의 크기를 헤더에 기록
4. 패킷 전체 길이에서 헤더 길이를 빼면 데이터의 크기를 계산할 수 있으므로 수신측에서 이 방법에 따라 크기를 산출
5. 송신한 데이터가 몇 번째 바이트부터 시작되는 몇 바이트 분의 것인지 알 수 있음

- ACK 번호: 시퀀스 번호 + 크기가 되며 이 ACK 번호를 되돌려주는 동작을 통해 수신 확인 응답을 함. 이를 통해 상대가 어디까지 수신했는지를 파악함
- TCP의 데이터 송수신 동작은 양방향이므로 두 가지 데이터 흐름이 모두 위와 같이 동작해야 함. -> 좌우를 역전시킨 것을 덧붙이면 됨

#### 실제 움직임

1. 클라이언트가 서버에 시퀀스 번호 초기값을 보냄
2. 서버가 클라이언트에 ACK번호와 시퀀스 번호 초기값을 보냄
3. 클라이언트가 서버에 ACK 번호를 보냄

-------------connect 동작--------------

4. 클라이언트(서버)가 서버(클라이언트)에 시퀀스 번호 + 데이터를 보냄
5. 서버(클라이언트)가 클라(서버)에 ACK번호를 보냄

--------------송수신동작---------------

- 위 구조는 수신측에 패킷이 올바르게 도착한 것을 확인하고 도착하지 않으면 다시 보내므로 네트워크의 어디에서 오류가 발생했더라도 그것을 전부 검출하여 회복 처리를 취할 수 있음
- 따라서, LAN 어댑터, 버퍼, 라우터 모두 회복 조취를 취하지 않음
- 도중에 케이블이 분리되거나 서버가 다운되는 등의 이유로 TCP가 아무리 다시 보내도 데이터가 도착하지 않으면 데이터 송신동작을 강제로 종료하고 애플리케이션에 오류를 통지함

### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정

타임아웃 값 - ACK 번호가 돌아오는 것을 기다리는 시간

- 네트워크가 혼잡하여 정체가 일어나면 ACK 번호가 돌아오는 것이 지연되므로 이것을 예측하여 대기 시간을 어느 정도 길게 설정해야 함
- 반면에 너무 길면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 됨
- 따라서 TCP는 대기 시간을 동적으로 변경하는 방법을 취하고 있음.
- ACK번호가 돌아오는 시간을 기준으로 대기 시간을 판단.(데이터 송신 동작을 실행하고 있을 때 항상 ACK번호가 돌아오는 시간을 계측해둠)

### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리

- ACK 번호가 돌아올 때까지의 시간 동안 아무 일도 하지 않고 기다리는 것은 시간낭비
- TCP는 윈도우 제어라는 방식에 따라 송신과 ACK 번호 통지의 동작을 실행함
- 윈도우 제어는 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법

#### 윈도우 제어 방식

1. 수신측의 TCP는 패킷을 수신하면 일단 수신용 버퍼 메모리에 데이터를 일시 보관
2. 수신측에서는 ACK 번호를 계산하거나 조각을 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네주어야 함
3. 애플리케이션에 건네주는 속도보다 빠른 속도로 데이터가 도착하면 수신버퍼에 데이터가 쌓여서 넘쳐버림.
4. 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고, 수신측은 이 양을 초과하지 않도록 송신 동작을 실행

- 수신측은 수신 버퍼에 데이터를 임시 보관하고 수신 처리를 진행
- 수신 처리가 끝나고 수신 버퍼에 빈 부부닝 생기면 그 분량만큼 수신할 수 있는 데이터의 양을 늘리므로 TCP 헤더의 윈도우 필드에서 이것을 송신측에 알림
- 윈도우 사이즈 - 수신 가능한 데이터 양의 최대값. TCP를 정밀 조정하는 매개변수의 하나

### ACK 번호와 윈도우를 합승

- 윈도우 통지가 필요한 것은 수신측이 수신 버퍼에서 데이터를 추출하여 애플리케이션에 건네주었을 때
- ACK 번호는 수신측에서 데이터를 받았을 때 내용을 조사하여 정상 수신을 확인할 수 있는 경우에만 송신측에 보냄
- 수신측은 ACK 번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다림.
- 기다리는 사이에 다음 통지 동작이 일어나면 양쪽을 상승시켜서 한 개의 패킷으로 묶어서 보냄.
- 복수의 ACK 번호 통지가 연속해서 일어난 경우에도 패킷의 수를 줄일 수 있음. ACK 번호는 데이터를 어디까지 받았는지, 즉 수신한 데이터의 끝이 어디인지를 알리는 것이므로 ACK 번호 통지가 연속하여 일어나면 최후의 것만 통지하고 도중의 것은 생략해도 상관없음 -> 패킷 줄일 수 있음
- 윈도우 통지도 위와 마찬가지.

### HTTP 응답 메시지를 수신

1. 프로토콜 스택은 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네줌
2. 리퀘스트 메시지의 송신을 완료
3. 응답 메시지가 돌아올 때까지 다소 시간이 걸리므로 수신 버퍼에 데이터가 들어가지 않음
4. 프로토콜 스택은 의뢰받은 작업, 즉 수신 버퍼에서 수신 데이터를 추출하여 애플리케이션에 건네주는 작업을 보류
5. 서버에서 응답 메시지의 패킷이 도착했을 때 그것을 수신하여 애플리케이션에 건네주는 작업을 재개



## 서버에서 연결을 끊어 소켓을 말소

### 데이터 보내기를 완료했을 때 연결을 끊음

- 데이터 송수신을 종료하는 것은 애플리케이션이 송신해야 하는 데이터를 전부 송신 완료했다고 판단했을 때
- 송신을 완료한 측이 연결 끊기 단계로 들어가는데, 어디에서 데이터 송수신 동작이 끝나는지는 애플리케이션에 따라 다름

#### 서버측에서 연결 끊기 단계에 들어가는 경우

1. 서버측의 애플리케이션이 close를 호출함
2. 서버측의 프로토콜 스택이 TCP 헤더를 만들고, 여기에 연결 끊기를 나타내는 정보를 설정함(컨트롤 비트의 FIN 비트에 1을 설정하고, IP 담당 부분에 의뢰하여 클라이언트에 송신해달라고 함)
3. 서버측의 소켓에 연결 끊기 동작에 들어갔다는 정보를 기록
4. 서버에서 FIN에 1을 설정한 TCP 헤더가 도착하면 클라이언트측의 프로토콜 스택은 자신의 소켓에 서버측이 연결 끊기 동작에 들어갔다는 것을 기록
5. FIN을 1로 설정한 패킷을 받은 사실을 알리기 위해 ACK 번호를 서버측에 반송하고, 이것이 끝나면 애플리케이션이 데이터를 가지러 올 때까지 기다림
6. 애플리케이션이 read를 호출하여 데이터를 가지러 오면 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 사실을 애플리케이션에 알림
7. 클라이언트측의 애플리케이션도 close를 호출하여 데이터 송수신 동작을 끝냄
8. 클라이언트측의 프로토콜 스택은 서버측과 마찬가지로 FIN 비트에 1을 설정한 TCP 헤더를 만들고 IP 담당 부분에 의뢰하여 송신한 후 서버에서 ACK 번호가 돌아오면 서버와의 통신이 끝남

### 소켓을 말소

서버와의 통신이 끝나면 소켓을 사용하여 서버와 통신할 수 없게 됨. 이 때 소켓은 필요 없지만, 거기서 바로 소켓을 말소하지 않고 잠시 기다린 후 소켓을 말소함

1. 클라이언트가 FIN 송신
2. 서버가 ACK 번호 송신
3. 서버가 FIN 송신
4. 클라이언트가 ACK 번호 송신

이 경우 소켓이 바로 말소되었으면 ACK 번호를 송신할 수 없음.

명확한 규정은 없으나 일반적으로 보통 몇 분 정도 기다리고 나서 소켓을 말소함

### 데이터 송수신 동작을 정리

1. 서버측에서 애플리케이션을 동작시켜 소켓을 만들고 접속 대기 상태로 만듬
2. 클라이언트에서 애플리케이션을 동작시켜 소켓을 만들고 서버를 향해 접속 동작을 실행
3. 클라이언트가 SYN을 1로 만든 TCP 헤더를 서버에 보냄(시퀀스 번호의 초기값 포함, 서버가 송신할 때 이용하는 윈도우 통지값도 기록되어있음)
4. 서버에서 SYN을 1로 만든 TCP의 헤더가 돌아옴(클라와 마찬가지의 헤더)
5. 접속이 끝나고 데이터 송수신 단계에 들어감
6. 클라이언트(서버)에서 전송할 데이터를 작성하여 TCP계층에 넘겨줌
7. TCP계층에서 적당한 크기의 조각으로 분할하고 TCP 헤더를 맨 앞에 부가하여 서버(클라이언트)에 전송.(시퀀스 번호 포함)
8. 서버(클라이언트)가 ACK 번호를 클라이언트(서버)에 반송
9. 최초의 데이터 조각인 경우 서버(클라이언트)는 받기만 하지만 데이터 송수신이 진행되면 애플리케이션에 데이터를 건네주어 수신 버퍼에 빈 영역이 생기는데, 이 때 윈도우의 값도 기록하여 클라이언트(서버)에 통지
10. 클라이언트(서버)에서 서버(클라이언트)에 리퀘스트 메시지를 보내면 서버(클라이언트)가 응답 메시지를 반송
11. 연결 끊기 단계에 들어감
12. 서버(클라이언트)가 FIN을 1로 만든 TCP 헤더를 전송함
13. 이것을 받은 클라이언트(서버)가 ACK 번호의 TCP 헤더를 반송
14. 이후 클라이언트(서버)가 FIN을 1로 만든 TCP의 헤더를 전송
15. 마지막으로 서버(클라이언트)가 ACK를 보내며 끝



## IP와 이더넷의 패킷 송수신 동작

### 패킷의 기본

- 패킷은 **헤더**와 **데이터**의 두 부분으로 구성됨
- 헤더에는 수신처를 나타내는 주소 등의 제어 정보가 들어있음
- 패킷의 송신처가 되는 기기가 패킷을 만들고 가장 가까운 중계 장치에 송신
- 패킷이 가장 가까운 중계 장치에 도착하고, 중계 장치는 도착한 패킷의 헤더를 조사하여 패킷의 목적지를 판단(수신처가 어느 방향에 있는지에 대한 정보를 기록한 표와 같은 것을 사용)
- 송신처였던 기기가 수신처가 되는 상태의 경우 명확하게 구별하지 않는 편이 편리할 수 있음. 이러한 경우 송신처와 수신처의 기기를 묶어 '엔드 노드'라고 함
- 패킷 운반에 있어 라우터와 허브의 역할
  1. 라우터가 목적지를 확인하여 다음 라우터를 나타냄 - IP의 규칙 사용(MAC 헤더)
  2. 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착 - 이더넷의 규칙 사용(IP 헤더)

1. 송신처에서 패키스이 목적지가 되는 액세스 대상 서버의 IP 주소를 IP 헤더의 수신처에 기록함
2. 패킷의 목적지가 분명해지므로 IP는 이 수신처가 어느 방향에 있는지를 조사하고, 그 방향에 있는 다음 라우터를 조사함
3. 조사한 라우터에 도착하도록 이더넷의 의뢰함
4. 다음 라우터에 할당된 이더넷의 주소(MAC주소)를 조사하고, 그것은 MAC 헤더에 기록
5. 반복

- 허브는 패킷의 목적지를 판단하기 위한 이더넷용 표가 있어 이더넷의 헤더의 수신처 정보와 표를 결합해 패킷의 목적지를 판단하여 중계함
- 허브가 복수면 허브를 순차적으로 경유하여 패킷이 진행됨
- 패킷이 다음 라우터에 도착하면 다음에 어느 라우터에 패킷을 중계하면 좋을지를 결정
- 다음 라우터에 패킷을 건네기 위해 라우터의 MAC 주소를 조사하고, MAC 헤더를 바꿔쓰어 패킷을 다음 라우터에 전송
- 무선 LAN, ADSL, FTTH 등 IP의 의뢰를 받아 패킷을 운반할 수 있는 것이면 무엇이든지 이더넷 대신 사용할 수 있음

### 패킷 송수신 동작의 개요

- IP담당 부분은 패킷을 상대에게 송출만 하기 때문에 그 뒤에 상대가 있는 곳까지 패킷을 운반하는 것은 허브나 라우터 같은 네트워크 기기의 역할이 되므로 IP 담당 부분은 패킷을 운반하는 동작 전체에서 입구 부분에 불과함

1. TCP계층에서 데이터의 조각에 TCP 헤더를 부가한 것을 IP 계층으로 건넴
2. 이 때 TCP 계층에서 IP 주소와 함께 패킷을 넘겨주어 IP 계층에서 IP 헤더와 MAC 헤더를 작성
   - IP헤더 - IP 프로토콜에 규정된 규칙에 따라 IP 주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어 정보를 기록한 것
   - MAC헤더 - 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어 정보
3. 만든 패킷을 네트워크용 하드웨어에 넘겨줌(이더넷이나 무선 LAN, NIC)
4. NIC에 의해 전기나 빛의 신호 상태로 바뀌어 케이블에 송출됨
5. 신호는 허브나 라우터 등의 중계 장치에 도착하고, 중계 장치가 상대가 있는 곳까지 패킷을 전달함

### 수신처 IP 주소를 기록한 IP 헤더를 만듬

IP 계층은 TCP 계층에서 패킷 송수신 의뢰를 받으면 IP 헤더를 만들어 TCP 헤더 앞에 붙임

- 버전, 헤더길이, 서비스 유형, 전체 길이, ID 정보, 플래그, 프래그먼트 오프셋 등등..

IP 계층은 스스로 수신처를 판단하지 않고 애플리케이션이 지정한 상대에게 패킷을 송신할 뿐이므로 애플리케이션이 IP 주소를 잘못 지정해도 그대로 IP 헤더로 설정

- IP 계층은 송신처 IP 주소도 설정함.
- IP 주소는 컴퓨터에 할당되는 것이 아니라 LAN 어댑터에 할당되므로 여러 개의 LAN 어댑터를 장착하면 각 LAN 어댑터에 서로 다른 IP 주소가 할당됨
- 패킷을 건네줄 상대를 판단하는 방법은 라우터가 경로표를 사용하여 다음 라우터를 결정하는 동작과 같음

1. 소켓에 기록되어 있는 수신처 IP 주소를 경로표의 '네트워크 대상' 항목과 비교하여 어느 행에 해당하는지 찾아냄. 
2. 'Interface'항목은 NIC를 나타내고, NIC에서 패킷을 송신하면 상대에 패킷을 전해줄 수 있다는 의미
3. 'Gateway'항목은 다음 라우터의 IP 주소를 기록하게 되어 있어서 IP 주소를 가진 라우터에 패킷을 건네주면 라우터가 목적지에 패킷을 중계해 준다는 것을 나타냄
4. 기본 게이트웨이 - 다른 곳에 일치하는 것이 없으면 이 행이 해당하는 것으로 간주
5. 어느 NIC에서 패킷을 송신해야 하는지 알고 나서 NIC에 할당되어 있는 IP 주소를 IP헤더의 송신처 IP 주소로 설정

### 이더넷용 MAC 헤더를 만듬

IP 헤더를 만들었으면 앞에 MAC 헤더를 붙임

IP헤더의 수신처 IP 주소에 패킷을 전달하는 목적지가 쓰여있으므로 이것을 보면 패킷을 어디로 운반해야 하는지 판단할 수 있는데, 이더넷에는 TCP/IP 개념이 통용되지 않음

따라서 이더넷의 수신처 판단 구조로 사용하는 것이 MAC헤더

- 수신처 MAC 주소, 송신처 MAC 주소, 이더 타입(IP 헤더의 프로토콜 번호와 비슷함)

IP주소는 32비트지만 MAC주소는 48비트이며, IP주소와 달리 48비트를 한 개의 값으로 생각함

MAC주소는 NIC를 제조할 때 그 안에 있는 ROM에 기록되므로 여기에 기록되어 있는 값을 읽어와서 MAC 헤더로 설정

#### 수신처 MAC 주소

여기에 패킷을 건네주는 상대의 MAC주소를 기록해야 함. 그러나 전송하기 전의 시점에서는 아직 누구에게 패킷을 건네주어야 할지 모르기 때문에 건네줄 상대가 누구인지를 조사하는데, 이것이 경로표에 기록되어있음. 경로표에서 찾은 일치하는 행의 'Gateway' 항목에 기록되어 있는 IP 주소의 기기가 패킷을 건네줄 상대가 됨

### ARP로 수신처 라우터의 MAC 주소를 조사

- ARP(Address Resolution Protocol) - 이더넷에는 연결되어 있는 전원에게 패킷을 전달하는 브로드캐스트라는 구조가 있는데, 이 구조를 이용하여 특정 IP 주소를 갖고 있는 기기를 찾음. 이후 해당 IP 에 해당하는 기기가 MAC 주소를 응답.
- 이것을 MAC 헤더에 설정하여 MAC 헤더를 만듬
- 패킷을 보낼 때마다 이 동작을 하면 ARP 의 패킷이 불어나기 때문에 한 번 조사한 결과는 ARP 캐시라는 메모리 영역에 보존하여 다시 이용함.
- 즉, 패킷을 송신할 때 우선 ARP 캐시를 조사하여 거기에 상대의 MAC 주소가 저장되어 있으면 ARP를 조회하지 않고 ARP 캐시에 보존되어 있는 값을 사용
- ARP캐시에 저장된 MAC 주소를 언제까지나 사용하면 IP 주소를 설정하여 고쳐진 경우 등 데이터가 일치하지 않을 수 있기 때문에 ARP 캐시에 저장된 값은 시간이 되면 삭제하게 되어있음

### 이더넷의 기본

이더넷 - 다수의 컴퓨터가 여러 상대와 자유롭게 적은 비용으로 통신하기 위해 고안된 통신 기술

#### 이더넷의 원형

- 네트워크의 실체는 케이블만 있음
- 컴퓨터가 신호를 송신하면 케이블을 통해 네트워크 전체에 신호가 흐르고 전원에게 신호가 도착함
- 이런 방식은 수신처를 특정할 수 없기 때문에 신호의 맨 앞에 수신처 주소를 써둠
- 이 동작을 제어하기 위해 MAC 헤더를 사용함

#### 리피터 허브를 이용한 파생형

- 기존에 신호를 흘리던 트렁크 케이블이 리피터 허브로 바뀌고, 트랜시버 케이블이 트위스트 페어 케이블로 바뀜
- 신호가 전원에게 전달된다는 기본적인 성질은 변하지 않음

#### 스위칭 허브를 이용한 형태

- 전원에게 신호가 전달되지 않음
- 수신처 MAC 주소로 나타내는 원하는 기기가 존재하는 부분에만 신호가 흐름

### IP 패킷을 전기나 빛의 신호로 변환하여 송신

- IP계층에서 만들어진 패킷은 메모리에 기억된 디지털 데이터이므로 이것을 그대로 상대에게 보낼 수 없음
- 따라서 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크의 케이블에 송출하는데, 이것이 송수신 동작의 본질
- 이 동작을 실행하는 것이 NIC(LAN어댑터라고도 함)

#### NIC 중요 구성 요소

1. 버퍼 메모리 - 송수신하는 패킷을 일시적으로 저장하는 메모리
2. MAC, ROM - 충돌 검출/다시 송신 등 이더넷의 송수신 동작을 제어하는 부분, MAC 주소를 기입하는 부분
3. PHY(MAU) - 신호를 송신하는 회로와 신호를 수신하는 회로를 합친 것
4. RJ-45 커넥터 - LAN 케이블을 접속하는 커넥터

- 전원을 공급하여 OS를 시동할 대 LAN 드라이버가 하드웨어의 초기화 작업을 수행해야 사용 가능한 상태가 됨
- 이 때 이더넷의 송수신 동작을 제어하는 MAC회로에 MAC 주소를 설정함
- NIC의 ROM에는 전 세계적으로 중복되지 않도록 일원화해서 관리하는 MAC 주소를 제조할 때 기록하므로 이것을 읽어와서 MAC 회로에 설정함

### 패킷에 3개의 제어용 데이터를 추가

1. NIC 드라이버는 IP 계층에서 패킷을 받으면 그것을 LAN 어댑터의 버퍼 메모리에 복사함
2. 복사를 마친 후 패킷을 송신하도록 MAC 회로에 명령을 보내면 MAC 회로의 작업이 시작됨
3. MAC회로는 송신 패킷을 버퍼 메모리에서 추출하고 맨 앞에는 프리앰블과 스타트 프레임 딜리미터라는 두 개의 데이터를, 맨 끝에는 프레임 체크 시퀀스(FCS)라는 오류 검출용 데이터를 부가함
4. 프리앰블 - 송신하는 패킷을 읽을 때의 타이밍을 잡기 위한 것으로, '10101010...'과 같이 1과 0이 번갈아 나타나는 비트열이 56비트 이어진 것
5. 스타트 프레임 딜리미터 - 끝이 11이라는 비트 패턴이며, 이 때문에 파형이 변함. 이것을 패킷의 개시 위치로 간주
6. 디지털 데이터를 전기 신호로 나타낼 때는 0과 1의 비트 값을 전압이나 전류의 값에 대응시킴
7. 그러나 실제 신호에는 각 비트의 구분을 나타내는 보조선이 있으므로 각 비트의 구분이 어디까지인지 판단하면서 전압이나 전류의 값을 읽어야 함
8. 1과 0이 이어지면 신호의 변화가 없어져서 비트 구분을 판단할 수 없게 된다는 문제가 발생
9. 이를 해결하기 위한 가장 알기 쉬운 방법은 데이터를 나타내는 신호와는 별도로 비트 구분을 나타내는 클록이라는 신호를 보내는 방법임
10. 데이터 신호와 클록 신호를 합성하여 한 개의 신호로 만들면 이 문제를 해결할 수 있음
11. 클록 신호의 타이밍을 판단하는 것이 중요한데 10메가비트/초와 같이 클록이 변화하는 주기가 결정되어 있으므로 **프리앰블**을 통해 클록 신호의 타이밍을 잡기 위한 특별한 신호를 패킷 앞에 부가하면 됨
12. FCS는 패킷을 운반하는 도중에 잡음 등의 영향으로 파형이 흐트러져 데이터가 변한 경우 이것을 검출하기 위해 사용함. 32비트의 비트열이며, 패킷의 맨 앞부분에서 맨 끝까지의 내용을 어떤 계산식에 기초하여 계산한 것. CRC와 같은 종류로 계산의 바탕이 된 데이터의 값이 1비트라도 변화하면 계산한 결과도 달라진 값을 취하도록 고안되어있음

### 허브를 향해 패킷을 송신함

프리앰블, 스타트 프레임 딜리미터, FCS의 세 가지를 부가하면 케이블에 송출하는 패킷이 완성됨.

신호를 송신하는 동작에는 리피터 허브를 사용했을 때의 반이중 모드와 스위칭 허브를 사용한 전이중 모드의 두 가지가 있음

#### 반이중 모드

1. 케이블에 다른 기기가 송신한 신호가 흐르고 있는지 조사하고, 신호가 흐르고 있으면 그것이 끝날 때까지 기다림(신호가 흐르고 있을 때 송신 동작을 시작하면 충돌하기 때문)
2. 신호가 정지했거나 애초부터 신호가 흐르고 있지 않았으면 송신 동작을 시작.
3. 송신 동작은 먼저 MAC 회로가 프리앰블의 맨 앞부터 1비트씩 차례로 디지털 데이터를 전기 신호로 변환하고, 이것을 PHY또는 MAU라는 송수신 신호부분에 보냄
4. 이때 디지털 데이터를 신호로 변환하는 속도가 전송 속도
5. PHY(MAU)회로는 이 신호를 케이블에 송출하는 형식으로 변환하여 송신
6. 이더넷은 케이블의 종류나 전송 속도에 따라 몇 가지 신호 형식이 규정되어 있지만, MAC 회로는 이러한 형식의 차이에 신경쓰지 않고 어느 형식으로도 변환할 수 있는 공통 형식의 신호를 PHY(MAU) 회로에 보냄
7. PHY(MAU)회로에서 실제로 케이블에 송출하는 형식으로 변환하여 송신
8. PHY(MAU)회로 - MAC 회로가 송신한 신호의 형식을 변환하기 위한 변환 회로
9. PHY(MAU) 회로가 MAC 회로에서 받은 신호를 케이블에 송신할 때 단지 송신 동작만 실행하는 것이 아니라 수신 신호선에서 신호가 흘러들어오는지 감시함 -> 송신을 시작할 때는 수신 신호선에 신호가 흐르지 않을 때
10. 이더넷은 상대에게 완전하게 도착했는지 확인하지 않음 -> 오류가 발생해도 프로토콜 스택의 TCP가 검출하므로 신호를 송신할 때 오류를 확인할 필요가 없음
11. 반이중 모드의 경우 동시에 송신 동작에 들어간 기기가 있으면 서로의 신호가 뒤섞여서 분간할 수 없는 상태가 되는데, 이것이 **충돌**이라는 현상
12. 송신 동작을 중지하고 충돌이 일어난 사실을 다른 기기에 알리기 위해 재밍 신호라는 특수한 신호를 흘리고 대기

#### 전이중 모드

전이중 모드에서는 송신과 수신을 동시에 실행하면서 충돌이 일어나지 않음

### 돌아온 패킷을 받음

- 리피터 허브를 이용한 반이중 동작의 이더넷에서는 1대가 송신한 신호가 리피터 허브에 접속된 케이블 전부에 흘러감
- 신호의 맨 앞에는 프리앰블이 있으므로 파형에서 타이밍을 계산하여 스타트 딜리미터가 나오면, 그 다음 비트부터 디지털 데이터로 변환하여 동작을 개시
- PHY(MAU)회로에서 신호를 공통 형식으로 변환하여 MAC 회로에 보냄
- MAC 회로에서 신호를 맨 앞부터 차례대로 디지털 데이터로 변환하여 버퍼 메모리에 저장
- 신호의 마지막에 이르면 맨 끝의 FCS를 검사
- FCS에 문제가 없으면 MAC 헤더의 수신처 MAC 주소를 조사하여 자신과 비교
- 폐기 or 버퍼 메모리에 저장
- 본체에 통지(인터럽트 구조 - 컴퓨터 본체가 실행하고 있는 작업에 끼어들어 NIC쪽에 주의시키는 것)
- 인터럽트 작동방식
  1. NIC가 확장 버스 슬롯 부분에 있는 인터럽트용 신호선에 신호를 보냄
  2. 신호선은 컴퓨터 본체측의 인터럽트 컨트롤러를 통해 CPU에 연결되어 있으며, 신호가 흘러오면 CPU는 실행하고 있던 작업을 일시적으로 보류하고 OS 내부의 인터럽트 처리용 프로그램쪽으로 전환
  3. 여기서 NIC 드라이버가 호출되어 NIC를 제어하면서 송수신 동작을 실행함
  4. 인터럽트에는 번호가 할당되어 있어서 NIC를 설치할 때 번호를 하드웨어로 설정함
  5. 현재는 PnP사양에 따라 번호를 자동으로 설정하므로 인터럽트 번호를 걱정하지 않아도 됨
  6. 인터럽트에 의해 NIC 드라이버가 동작하고 NIC의 버퍼 메모리에서 수신한 패킷을 추출하면, NIC 드라이버는 MAC 헤더의 타입 필드의 값으로부터 프로토콜을 판별

### 서버의 응답 패킷을 찾아서 IP에서 TCP로 넘김

1. 반송된 패킷의 프로토콜 타입에 맞춰 프로토콜 스택에 패킷을 넘김(NIC 드라이버)
2. IP 계층에서 IP 헤더부터 조사하여 포맷에 문제가 없는지 확인하고, 수신처 IP주소를 조사 후 패킷 수신
3. 수신처 IP가 자신과 같지 않다면 IP 계층에서 ICMP라는 메시지로 상대에게 오류를 통지, 올바르면 수신